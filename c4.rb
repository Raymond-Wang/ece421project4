#!/usr/bin/env ruby
require 'rubygems'
require 'gtk2'

class PreconditionError < StandardError; end
class PostconditionError < StandardError; end
class InvariantError < StandardError; end

class Game
    GAME_C4 = 'C4'
    GAME_OTTO = 'OTTO'
    GAMES = [GAME_OTTO,GAME_C4]
    MIN_DIFFICULTY = 0
    MAX_DIFFICULTY = 3
    HEIGHT = 6
    WIDTH = 7
    # Row 0 is at the top, Col 0 is on the left
    
    def initialize(dif, players=[], game=GAME_C4)
        if not(dif.respond_to? :between? and dif.between?(MIN_DIFFICULTY,MAX_DIFFICULTY))
            raise PreconditionError, 'Invalid difficulty.'
        end
        if not(players.respond_to? :each)
            raise PreconditionError, 'Players should be an enumerable.'
        else
            players.each { |p| 
                if not player.kind_of? Player 
                    raise PreconditionError, 'Players enumerable should only contain player objects.'
                end
            }
        end
        print game
        if not(GAMES.include? game)
            raise PreconditionError, "Strategy should be one of #{GAMES.inspect}"
        end

        # Array of all players. Can be modified dynamically as players leave
        # and enter.
        @players = players 
        # Index of the current player.
        @currentPlayer = 0
        @difficulty = dif
        @game = game 
        @board = Array.new(HEIGHT) { Array.new(WIDTH) } 

        # Initialize our strategy
        initStrategy
    end

    # Somewhat of a factory method for the strategy but 
    # we don't yet require a factory abstraction
    def initStrategy
        if @game == GAME_C4 
            @strategy = C4Strategy.new self
        elsif @game == GAME_OTTO
            @strategy = OttoStrategy.new self
        end
    end

    # Strategy dependent methods are delegated.
    def win?
        @strategy.win?
    end
    
    def move
        @strategy.move
    end
end

class Player
    TYPE_AI = 'AI'
    TYPE_HUMAN = 'HUMAN'

    def initialize(name,type)
        @name, @type = name, type
    end

    def move
    end
end

class Move
    attr_accessor :x, :y
    def initialize(x,y)
        @x, @y = x, y
    end
end

# NOTE Strategies can have their own instance variables to help manage things.
# For example a hierarchical tree or whatever it takes. It has access
# to the full game state via game.
# The strategy is responsible for two, somewhat distinct goals:
# 1. Check if the current game state is a victory.
#
# Ideas (might be overkill!!)
# http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
class Strategy
    def initialize(game)
        # We give the stategy access to the entire gamemodel which
        # includes the board and stats on players.
        # Strategy might be player quantity dependent for example
        @game = game
    end

    def horizontal(i,j,arr)
	for k in 0..(arr.length-1)
	    if @board[i][j+k] != arr[k]
		return false
	    end
	end
	return true
    end

    def vertical(i,j,arr)
	for k in 0..(arr.length-1)
	    if @board[i+k][j] != arr[k]
		return false
	    end
	end
	return true
    end

    def diagonaldown(i,j,arr)
	for k in 0..(arr.length-1)
	    if @board[i+k][j+k] != arr[k]
		return false
	    end
	end
	return true
    end

    def diagonalup(i,j,arr)
	for k in 0..(arr.length-1)
	    if @board[i-k][j+k] != arr[k]
		return false
	    end
	end
	return true
    end

    def find(arr)
	if (arr.length > 6)
	    raise PreconditionError, 'Search array too long.'
	end
	if (arr.empty)
	    raise PreconditionError, 'Search array is empty.'
	end
	for i in 0..5
	    for j in 0..(7-arr.length)
		if horizontal(i,j,arr)
		    return i,j,'horizontal'
		end
	    end
	end
	for i in 0..(6-arr.length)
	    for j in 0..6
		if vertical(i,j,arr)
		    return i,j,'vertical'
		end
	    end
	end
	for i in 0..(6-arr.length)
	    for j in 0..(7-arr.length)
		if diagonaldown(i,j,arr)
		    return i,j,'diagonaldown'
		end
	    end
	end
	for i in (arr.length-1)..5
	    for j in 0..(7-arr.length)
		if diagonalup(i,j,arr)
		    return i,j,'diagonalup'
		end
	    end
	end
	return -1,-1,'notfound'
    end

    def top(i)
	for j in 6..0
	    if @board[i][j] == 0
		return j
	    end
	end
	return -1
    end

    def hasAdjacent(row,col,piece)
	fromI = (row == 5) ? 0 : -1
	toI = (row == 0) ? 0 : 1
	fromJ = (col == 0) ? 0 : -1
	toJ = (col == 6) ? 0 : 1
	for i in fromI..toI
	    for j in fromJ..toJ
		if @board[row+i][col+j] == piece
		    return true
		end
	    end
	end
	return false
    end
    
    def move
        raise NotImplementedError, 'Concrete, game specific strategies should implement move.'
    end

    # Evaluate position based on minimax.
    # Perhaps we want per-player evaluation tables generated by running the
    # evaluation function?
    def evaluate
    end
    
    def win?
        raise NotImplementedError, 'Concrete, game specific strategies should implement win?.'
    end
end

class OttoStrategy < Strategy
end

class C4Easy < Strategy
    def move
	begin 
	    col = rand(7)
	    row = top(col)
	end until row > -1
	@board[row][col] = 2;
    end

    def win?
	p1,a,b = find([1,1,1,1])
	p2,c,d = find([2,2,2,2])
	return p1>0 || p2>0
    end

end

class C4Medium < Strategy
    def win?
	p1,a,b = find([1,1,1,1])
	p2,c,d = find([2,2,2,2])
	return p1>0 || p2>0
    end

    def move
	for col in 0..6
	    if (top(col) > -1)
	        @board[top(col)][col] = 2
	    end
	    if win?
		return
	    else 
		@board[top(col)][col] = 1
		if win?
		    @board[top(col)][col] = 2
		    return
	        end
	    end
	end
	begin 
	    col = rand(7)
	    row = top(col)
	end until row > -1
	@board[row][col] = 2;
    end
end

class C4Hard < Strategy
    def win?
	p1,a,b = find([1,1,1,1])
	p2,c,d = find([2,2,2,2])
	return p1>0 || p2>0
    end

    def move
	for col in 0..6
	    if (top(col) > -1)
	        @board[top(col)][col] = 2
	    end
	    if win?
		return
	    else 
		@board[top(col)][col] = 1
		if win?
		    @board[top(col)][col] = 2
		    return
	        end
	    end
	end
	from = rand(7)
	to = rand(7)
	for col in from..to
	    if(top(col) > -1)
		if(hasAdjacent(top(col),col,2))
		    @board[top(col)][col] = 2
		end
	    end
	end
	begin 
	    col = rand(7)
	    row = top(col)
	end until row > -1
	@board[row][col] = 2;
    end
end

# The builder is our view in this case.
class Controller
  attr :glade

  def initialize
    if __FILE__ == $0
      Gtk.init
      @builder = Gtk::Builder::new
      @builder.add_from_file("c4.glade")
      @builder.connect_signals{ |handler| method(handler) }

# Destroying the window will terminate the program
      window = @builder.get_object("window1")
      window.signal_connect( "destroy" ) { Gtk.main_quit }

# The 'Quit' button will terminate the program
      menu = @builder.get_object("Quit")
      menu.signal_connect( "activate" ) { Gtk.main_quit }

# The 'New' button will start a new game
      menu = @builder.get_object("New")
      menu.signal_connect( "activate" ) { setUpTheBoard }

# The 'Settings' button will open a new window called settings
      settings = @builder.get_object("Settings")
      settings.signal_connect( "activate" ) { openSettings() }

# The 'Settings' button will open a new window called settings
      about = @builder.get_object("About")
      about.signal_connect( "activate" ) { openAbout() }

# The 'OK' button in Settings will save the settings and close the window
      settingsOK = @builder.get_object("SettingsOK")
      settingsOK.signal_connect( "clicked" ) { saveSettings() }

# The 'Cancel' button in Settings will negate any changes to the settings and close the window
      settingsCancel = @builder.get_object("SettingsCancel")
      settingsCancel.signal_connect( "clicked" ) { hideSettings() }

# Attach a signal to each button
      1.upto(Game::HEIGHT*Game::WIDTH) { |i| 
         @builder.get_object("button" + i.to_s).signal_connect("clicked") {button_clicked(i)};
      }

      @game = Game.new 0

      setUpTheBoard

      window.show()
      Gtk.main()
    end
  end

  def openSettings
    dialog = @builder.get_object("dialog1")
    dialog.show()
    gameCombo = @builder.get_object("GameCombo")
    difficultyCombo = @builder.get_object("DifficultyCombo")
    gameCombo.active=@game
    difficultyCombo.active=@difficulty
  end

  def saveSettings
    gameCombo = @builder.get_object("GameCombo")
    difficultyCombo = @builder.get_object("DifficultyCombo")
    @game = gameCombo.active
    @difficulty = difficultyCombo.active
    hideSettings()
  end

  def hideSettings
    dialog = @builder.get_object("dialog1")
    dialog.hide()
  end

  def openAbout
    about = @builder.get_object("window2")
    about.show()
  end

  def setUpTheBoard

  end

  def button_clicked(tileNumber)
      puts tileNumber
  end  


  def win?

  end


  def threes(a,b,c)

  end


  def gtk_main_quit
    Gtk.main_quit()
  end


end


hello = Controller.new
