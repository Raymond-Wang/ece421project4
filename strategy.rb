require "./models"

# NOTE Strategies can have their own instance variables to help manage things.
# For example a hierarchical tree or whatever it takes. It has access
# to the full game state via game.
# The strategy is responsible for two, somewhat distinct goals:
# 1. Check if the current game state is a victory.
#
# Ideas (might be overkill!!)
# http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
class Strategy 
  def initialize(game)
    # We give the stategy access to the entire gamemodel which
    # includes the board and stats on players.
    # Strategy might be player quantity dependent for example
    @game = game
  end

  def horizontal(i,j,arr)
    for k in 0..(arr.length-1)
      if @board[i][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def vertical(i,j,arr)
    for k in 0..(arr.length-1)
      if @board[i+k][j] != arr[k]
        return false
      end
    end
    return true
  end

  def diagonaldown(i,j,arr)
    for k in 0..(arr.length-1)
      if @board[i+k][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def diagonalup(i,j,arr)
    for k in 0..(arr.length-1)
      if @board[i-k][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def find(arr)
    if (arr.length > Game::HEIGHT)
      raise PreconditionError, 'Search array too long.'
    end
    if (arr.empty?)
      raise PreconditionError, 'Search array is empty.'
    end
    for i in 0..(Game::HEIGHT-1)
      for j in 0..(Game::WIDTH-arr.length)
        if horizontal(i,j,arr)
          return i,j,i,j+4
        end
      end
    end
    for i in 0..(Game::HEIGHT-arr.length)
      for j in 0..(Game::WIDTH-1)
        if vertical(i,j,arr)
          return i,j, i+4,j
        end
      end
    end
    for i in 0..(Game::HEIGHT-arr.length)
      for j in 0..(Game::WIDTH-arr.length)
        if diagonaldown(i,j,arr)
          return i,j,i+4,j+4
        end
      end
    end
    for i in (arr.length-1)..(Game::HEIGHT-1)
      for j in 0..(Game::WIDTH-arr.length)
        if diagonalup(i,j,arr)
          return i,j,i-4,j+4
        end
      end
    end
    return -1,-1,-1,-1
  end

  def top(i)
    for j in Game::HEIGHT..0
      if @board[i][j] == 0
        return j
      end
    end
    return -1
  end

  def hasAdjacent(row,col,piece)
    fromI = (row == (Game::HEIGHT-1)) ? 0 : -1
    toI = (row == 0) ? 0 : 1
    fromJ = (col == 0) ? 0 : -1
    toJ = (col == (Game::WIDTH-1)) ? 0 : 1
    for i in fromI..toI
      for j in fromJ..toJ
        if @board[row+i][col+j] == piece
          return true
        end
      end
    end
    return false
  end

  def move
    raise NotImplementedError, 'Concrete, game specific strategies should implement move.'
  end

  # Evaluate position based on minimax.
  # Perhaps we want per-player evaluation tables generated by running the
  # evaluation function?
  def evaluate
  end

  def win?
    raise NotImplementedError, 'Concrete, game specific strategies should implement win?.'
  end
end

class OttoStrategy< Strategy
  def win?
    p1 = find([2,1,1,2])
    p2 = find([1,2,2,1])
    return p1>0 || p2>0
  end

  def winner
    p1 = find([1,2,2,1])
    p2 = find([2,1,1,2])
    if p1>0 && p2>0
      return 3
    end
    if p1>0
      return 1
    end
    if p2>0
      return 2
    end
    return 0
  end

  # Pass in 1 if looking for OTTO, returns coordinates for first and last piece
  # Pass in 2 if looking for TOOT, returns coordinates for first and last piece
  # Pass in 3 if looking for both, returns coordinates for first and last piece for both OTTO and TOOT
  def winningMove(winner)
    a,b,c,d = find([1,2,2,1])
    e,f,g,h = find([2,1,1,2])
    if winner == 1
      if a>0
        return a,b,c,d
      end
    end
    if winner == 2
      if e>0
        return e,f,g,h
      end
    end
    if winner == 3
      if a>0&&e>0
        return a,b,c,d,e,f,g,h
      end
    end
    return -1,-1,-1,-1
  end

  def move
    for col in 0..6
      if (top(col) > -1)
        @board[top(col)][col] = 2
      end
      if winner == 2
        return
      elsif winner == 1
        @board[top(col)][col] = 1
      end
    end
    begin 
      col = rand(7)
      row = top(col)
    end until row > -1
    @board[row][col] = 1 + rand(1);
  end

end

class C4Strategy < Strategy
  def win?
    p1 = find([1,1,1,1])
    p2 = find([2,2,2,2])
    return p1>0 || p2>0
  end


  # Pass in 1 for player 1, returns coordinates for first and last piece
  # Pass in 2 for player 2, returns coordinates for first and last piece
  def winningMove
    a,b,c,d = find([1,1,1,1])
    if a>0
      return a,b,c,d
    else
      a,b,c,d = find([2,2,2,2])
      if a>0
        return a,b,c,d
      end
    end
    return -1,-1,-1,-1
  end

  def hasWin
      for col in 0..Game::HEIGHT
        if (top(col) > -1)
          @board[top(col)][col] = 2
        end
        if win?
          @board[top(col)][col] = 0
          return 2, col
        else 
          @board[top(col)][col] = 1
          if win?
            @board[top(col)][col] = 0
            return 1, col
          end
        end
      end
      return 0, 0
  end

  def move
    if @difficulty >= 2
      winner, col = hasWin
      if winner > 0
        @board[top(col)][col] = 2
        return
      end
    end
    if @difficulty == 3
      from = rand(6)
      to = rand(6)
      for col in from..to
        if(top(col) > -1)
          if(hasAdjacent(top(col),col,2))
            @board[top(col)][col] = 2
            winner, x = hasWin
            if winner != 1
              return
            end
            @board[top(col)][col] = 0
          end
        end
      end
    end
    if @difficulty >= 2
      for i in 1..10
        begin 
          col = rand(6)
          row = top(col)
        end until row > -1
        @board[row][col] = 2;
        winner, x = hasWin
        if winner == 1
          @board[row][col] = 0;
        else
          return
        end
      end  
    end
    begin 
      col = rand(6)
      row = top(col)
    end until row > -1
    @board[row][col] = 2;
  end
end


