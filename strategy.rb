require "./c4"

# NOTE Strategies can have their own instance variables to help manage things.
# For example a hierarchical tree or whatever it takes. It has access
# to the full game state via game.
# The strategy is responsible for two, somewhat distinct goals:
# 1. Check if the current game state is a victory.
#
# Ideas (might be overkill!!)
# http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
class Strategy < Model
  def initialize(game)
    # We give the stategy access to the entire gamemodel which
    # includes the board and stats on players.
    # Strategy might be player quantity dependent for example
    @game = game
  end

  def horizontal(i,j,arr)
    for k in 0..(arr.length-1)
      if @board[i][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def vertical(i,j,arr)
    for k in 0..(arr.length-1)
      if @board[i+k][j] != arr[k]
        return false
      end
    end
    return true
  end

  def diagonaldown(i,j,arr)
    for k in 0..(arr.length-1)
      if @board[i+k][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def diagonalup(i,j,arr)
    for k in 0..(arr.length-1)
      if @board[i-k][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def find(arr)
    if (arr.length > 6)
      raise PreconditionError, 'Search array too long.'
    end
    if (arr.empty)
      raise PreconditionError, 'Search array is empty.'
    end
    for i in 0..5
      for j in 0..(7-arr.length)
        if horizontal(i,j,arr)
          return i,j,'horizontal'
        end
      end
    end
    for i in 0..(6-arr.length)
      for j in 0..6
        if vertical(i,j,arr)
          return i,j,'vertical'
        end
      end
    end
    for i in 0..(6-arr.length)
      for j in 0..(7-arr.length)
        if diagonaldown(i,j,arr)
          return i,j,'diagonaldown'
        end
      end
    end
    for i in (arr.length-1)..5
      for j in 0..(7-arr.length)
        if diagonalup(i,j,arr)
          return i,j,'diagonalup'
        end
      end
    end
    return -1,-1,'notfound'
  end

  def top(i)
    for j in 6..0
      if @board[i][j] == 0
        return j
      end
    end
    return -1
  end

  def hasAdjacent(row,col,piece)
    fromI = (row == 5) ? 0 : -1
    toI = (row == 0) ? 0 : 1
    fromJ = (col == 0) ? 0 : -1
    toJ = (col == 6) ? 0 : 1
    for i in fromI..toI
      for j in fromJ..toJ
        if @board[row+i][col+j] == piece
          return true
        end
      end
    end
    return false
  end

  def move
    raise NotImplementedError, 'Concrete, game specific strategies should implement move.'
  end

  # Evaluate position based on minimax.
  # Perhaps we want per-player evaluation tables generated by running the
  # evaluation function?
  def evaluate
  end

  def win?
    raise NotImplementedError, 'Concrete, game specific strategies should implement win?.'
  end
end

class OttoEasy < Strategy
  def move
    begin 
      col = rand(7)
      row = top(col)
    end until row > -1
    @board[row][col] = 1 + rand(1);
  end

  def win?
    p1,a,b = find([2,1,1,2])
    p2,c,d = find([1,2,2,1])
    return p1>0 || p2>0
  end

  def winner
    p1,a,b = find([1,2,2,1])
    if p1>0
      return 1
    end
    p2,c,d = find([2,1,1,2])
    if p2>0
      return 2
    end
    return 0
  end
end

class OttoMedium < Strategy
  def win?
    p1,a,b = find([2,1,1,2])
    p2,c,d = find([1,2,2,1])
    return p1>0 || p2>0
  end

  def winner
    p1,a,b = find([1,2,2,1])
    if p1>0
      return 1
    end
    p2,c,d = find([2,1,1,2])
    if p2>0
      return 2
    end
    return 0
  end

  def move
    for col in 0..6
      if (top(col) > -1)
        @board[top(col)][col] = 2
      end
      if winner == 2
        return
      elsif winner == 1
        @board[top(col)][col] = 1
      end
    end
    begin 
      col = rand(7)
      row = top(col)
    end until row > -1
    @board[row][col] = 1 + rand(1);
  end

end


class C4Easy < Strategy
  def move
    begin 
      col = rand(6)
      row = top(col)
    end until row > -1
    @board[row][col] = 2;
  end

  def win?
    p1,a,b = find([1,1,1,1])
    p2,c,d = find([2,2,2,2])
    return p1>0 || p2>0
  end

end

class C4Medium < Strategy
  def win?
    p1,a,b = find([1,1,1,1])
    p2,c,d = find([2,2,2,2])
    return p1>0 || p2>0
  end

  def move
    for col in 0..6
      if (top(col) > -1)
        @board[top(col)][col] = 2
      end
      if win?
        return
      else 
        @board[top(col)][col] = 1
        if win?
          @board[top(col)][col] = 2
          return
        end
      end
    end
    begin 
      col = rand(6)
      row = top(col)
    end until row > -1
    @board[row][col] = 2;
  end
end

class C4Hard < Strategy
  def win?
    p1,a,b = find([1,1,1,1])
    p2,c,d = find([2,2,2,2])
    return p1>0 || p2>0
  end

  def move
    for col in 0..6
      if (top(col) > -1)
        @board[top(col)][col] = 2
      end
      if win?
        return
      else 
        @board[top(col)][col] = 1
        if win?
          @board[top(col)][col] = 2
          return
        end
      end
    end
    from = rand(6)
    to = rand(6)
    for col in from..to
      if(top(col) > -1)
        if(hasAdjacent(top(col),col,2))
          @board[top(col)][col] = 2
        end
      end
    end
    begin 
      col = rand(6)
      row = top(col)
    end until row > -1
    @board[row][col] = 2;
  end
end

