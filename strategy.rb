require "./models"

# NOTE Strategies can have their own instance variables to help manage things.
# For example a hierarchical tree or whatever it takes. It has access
# to the full game state via game.
# The strategy is responsible for two, somewhat distinct goals:
# 1. Check if the current game state is a victory.
#
# Ideas (might be overkill!!)
# http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
class Strategy
  ONGOING = 0
  P1_WIN = 1
  P2_WIN = 2
  DRAW = 3

  EASY = 0
  MEDIUM = 1
  HARD = 2

  @current_player = nil
  @opposing_player = nil

  def initialize(game)
    # We give the stategy access to the entire gamemodel which
    # includes the board and stats on players.
    # Strategy might be player quantity dependent for example
    @game = game
    @current_player = game.currentPlayer + 1
    @opposing_player = 2 - game.currentPlayer
  end

  def getSim
    Marshal.load(Marshal.dump(@game.board))
  end

  def horizontal(board,i,j,arr)
    for k in 0..(arr.length-1)
      if board[i][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def vertical(board,i,j,arr)
    for k in 0..(arr.length-1)
      if board[i+k][j] != arr[k]
        return false
      end
    end
    return true
  end

  def diagonaldown(board,i,j,arr)
    for k in 0..(arr.length-1)
      if board[i+k][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def diagonalup(board,i,j,arr)
    for k in 0..(arr.length-1)
      if board[i-k][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def find(board,arr)
    if (arr.length > Game::HEIGHT)
      raise PreconditionError, 'Search array too long.'
    end
    if (arr.empty?)
      raise PreconditionError, 'Search array is empty.'
    end
    for i in 0..(Game::HEIGHT-1)
      for j in 0..(Game::WIDTH-arr.length)
        if horizontal(board,i,j,arr)
          return i,j,i,j+3
        end
      end
    end
    for i in 0..(Game::HEIGHT-arr.length)
      for j in 0..(Game::WIDTH-1)
        if vertical(board,i,j,arr)
          return i,j, i+3,j
        end
      end
    end
    for i in 0..(Game::HEIGHT-arr.length)
      for j in 0..(Game::WIDTH-arr.length)
        if diagonaldown(board,i,j,arr)
          return i,j,i+3,j+3
        end
      end
    end
    for i in (arr.length-1)..(Game::HEIGHT-1)
      for j in 0..(Game::WIDTH-arr.length)
        if diagonalup(board,i,j,arr)
          return i,j,i-3,j+3
        end
      end
    end
    return -1,-1,-1,-1
  end

  def top(board,i)
    (Game::HEIGHT-1).downto(0) { |j|
      if board[j][i] == nil
        return j
      end
    }
    return -1
  end

  def hasAdjacent(board, row,col,piece)
    fromI = (row == 0) ? 0 : -1
    toI = (row == (Game::HEIGHT-1)) ? 0 : 1
    fromJ = (col == 0) ? 0 : -1
    toJ = (col == (Game::WIDTH-1)) ? 0 : 1
    for i in fromI..toI
      for j in fromJ..toJ
        if board[row+i][col+j] == piece
          return true
        end
      end
    end
    return false
  end

  def moveRemaining?
    simBoard = getSim
    for col in 0..(Game::WIDTH-1)
      if top(simBoard,col) >= 0
        return true
      end
    end
    return false
  end

  def move
    if !moveRemaining?
      return
    end
    simBoard = getSim
    if @game.difficulty >= MEDIUM
      winner, col = hasWin(simBoard)
      if winner > 0
        return col
      end
    end
    if @game.difficulty == HARD
      for col in 0..(Game::WIDTH-1)
        if(top(simBoard,col) > -1)
          if(hasAdjacent(simBoard,top(simBoard,col),col,@current_player))
            simBoard[top(simBoard,col)][col] = @current_player
            winner, x = hasWin(simBoard)
            simBoard[top(simBoard,col)][col] = nil
            if winner != @opposing_player && rand(1)==1
              return col
            end
          end
        end
      end
    end
    if @game.difficulty >= MEDIUM
      for i in 1..10
        begin 
          col = rand(6)
          row = top(simBoard,col)
        end until row > -1
        simBoard[row][col] = @current_player;
        winner, x = hasWin(simBoard)
	simBoard[row][col] = nil;
        if winner != @opposing_player
          return col
        end
      end  
    end
    begin 
      col = rand(6)
      row = top(simBoard,col)
    end until row > -1
    return col
  end

  # Evaluate position based on minimax.
  # Perhaps we want per-player evaluation tables generated by running the
  # evaluation function?
  def evaluate
  end

  def win?
    raise NotImplementedError, 'Concrete, game specific strategies should implement win?.'
  end

  def status
    raise NotImplementedError, 'Concrete, game specific strategies should implement status.'
  end
end

class OttoStrategy< Strategy
  def win(board)
    p1 = find(board,[1,2,2,1])
    p2 = find(board,[2,1,1,2])
    if p1[0]>=0
	return 1
    end
    if p2[0]>=0
	return 2
    end
    return 0
  end

  def status
    simBoard = getSim
    p1 = find(simBoard,[1,2,2,1])
    p2 = find(simBoard,[2,1,1,2])
    if p1[0]>0 && p2[0]>0
      return DRAW
    end
    if p1[0]>0
      return P1_WIN
    end
    if p2[0]>0
      return P2_WIN
    end
    return ONGOING
  end

  # Pass in 1 if looking for OTTO, returns coordinates for first and last piece
  # Pass in 2 if looking for TOOT, returns coordinates for first and last piece
  # Pass in 3 if looking for both, returns coordinates for first and last piece for both OTTO and TOOT
  def winningMove(winner)
    a,b,c,d = find([1,2,2,1])
    e,f,g,h = find([2,1,1,2])
    if winner == 1
      if a>=0
        return a,b,c,d
      end
    end
    if winner == 2
      if e>=0
        return e,f,g,h
      end
    end
    if winner == 3
      if a>=0&&e>=0
        return a,b,c,d,e,f,g,h
      end
    end
    return -1,-1,-1,-1
  end

  def hasWin(board)
      for col in 0..(Game::WIDTH-1)
      theTop = top(board,col)
        if (top(board,col) > -1)
          board[theTop][col] = @current_player
          if win(board)==@current_player
	    board[theTop][col] = nil
            return @current_player, col
          end
          board[theTop][col] = @opposing_player
          if win(board)==@opposing_player
            board[theTop][col] = nil
            return @opposing_player, col
          end  
          board[theTop][col] = nil
	end
      end
      return 0, 0
  end

end

class C4Strategy < Strategy
  def win?
    simBoard = getSim
    p1 = find(simBoard,[1,1,1,1])
    p2 = find(simBoard,[2,2,2,2])
    return p1[0]>=0 || p2[0]>=0
  end

  def win(board)
    p1 = find(board,[1,1,1,1])
    p2 = find(board,[2,2,2,2])
    return p1[0]>=0 || p2[0]>=0
  end

  def status
    simBoard = getSim
    p1 = find(simBoard,[1,1,1,1])
    p2 = find(simBoard,[2,2,2,2])
    if p1[0]>0
      return P1_WIN
    end
    if p2[0]>0
      return P2_WIN
    end
    return ONGOING
  end

  def winningMove
    simBoard = getSim
    a,b,c,d = find(simBoard,[1,1,1,1])
    if a>=0
      return a,b,c,d
    else
      a,b,c,d = find(simBoard,[2,2,2,2])
      if a>=0
        return a,b,c,d
      end
    end
    return -1,-1,-1,-1
  end

  def hasWin(board)
    for col in 0..(Game::WIDTH-1)
      theTop = top(board,col)
      if (top(board,col) > -1)
        board[theTop][col] = @current_player
        if win(board)
          board[theTop][col] = nil
          return @current_player, col
        end
        board[theTop][col] = @opposing_player
        if win(board)
          board[theTop][col] = nil
          return @opposing_player, col
        end  
        board[theTop][col] = nil
      end
    end
    return 0, 0
  end
end


