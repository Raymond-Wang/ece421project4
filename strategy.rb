require "./models"

# NOTE Strategies can have their own instance variables to help manage things.
# For example a hierarchical tree or whatever it takes. It has access
# to the full game state via game.
# The strategy is responsible for two, somewhat distinct goals:
# 1. Check if the current game state is a victory.
#
# Ideas (might be overkill!!)
# http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
class Strategy
  ONGOING = 0
  P1_WIN = 1
  P2_WIN = 2
  DRAW = 3

  EASY = 1
  MEDIUM = 2
  HARD = 3

  def initialize(game)
    # We give the stategy access to the entire gamemodel which
    # includes the board and stats on players.
    # Strategy might be player quantity dependent for example
    @game = game
  end

  def getSim
    Marshal.load(Marshal.dump(@game.board))
  end

  def horizontal(board,i,j,arr)
    for k in 0..(arr.length-1)
      if board[i][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def vertical(board,i,j,arr)
    for k in 0..(arr.length-1)
      if board[i+k][j] != arr[k]
        return false
      end
    end
    return true
  end

  def diagonaldown(board,i,j,arr)
    for k in 0..(arr.length-1)
      if board[i+k][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def diagonalup(board,i,j,arr)
    for k in 0..(arr.length-1)
      if board[i-k][j+k] != arr[k]
        return false
      end
    end
    return true
  end

  def find(board,arr)
    if (arr.length > Game::HEIGHT)
      raise PreconditionError, 'Search array too long.'
    end
    if (arr.empty?)
      raise PreconditionError, 'Search array is empty.'
    end
    for i in 0..(Game::HEIGHT-1)
      for j in 0..(Game::WIDTH-arr.length)
        if horizontal(board,i,j,arr)
          return i,j,i,j+3
        end
      end
    end
    for i in 0..(Game::HEIGHT-arr.length)
      for j in 0..(Game::WIDTH-1)
        if vertical(board,i,j,arr)
          return i,j, i+3,j
        end
      end
    end
    for i in 0..(Game::HEIGHT-arr.length)
      for j in 0..(Game::WIDTH-arr.length)
        if diagonaldown(board,i,j,arr)
          return i,j,i+3,j+3
        end
      end
    end
    for i in (arr.length-1)..(Game::HEIGHT-1)
      for j in 0..(Game::WIDTH-arr.length)
        if diagonalup(board,i,j,arr)
          return i,j,i-3,j+3
        end
      end
    end
    return -1,-1,-1,-1
  end

  def top(board,i)
    (Game::HEIGHT-1).downto(0) { |j|
      if board[j][i] == nil
        return j
      end
    }
    return -1
  end

  def hasAdjacent(board, row,col,piece)
    fromI = (row == (Game::HEIGHT-1)) ? 0 : -1
    toI = (row == 0) ? 0 : 1
    fromJ = (col == 0) ? 0 : -1
    toJ = (col == (Game::WIDTH-1)) ? 0 : 1
    for i in fromI..toI
      for j in fromJ..toJ
        if board[row+i][col+j] == piece
          return true
        end
      end
    end
    return false
  end

  def move
    raise NotImplementedError, 'Concrete, game specific strategies should implement move.'
  end

  # Evaluate position based on minimax.
  # Perhaps we want per-player evaluation tables generated by running the
  # evaluation function?
  def evaluate
  end

  def win?
    raise NotImplementedError, 'Concrete, game specific strategies should implement win?.'
  end
end

class OttoStrategy< Strategy
  def win?
    p1 = find([2,1,1,2])
    p2 = find([1,2,2,1])
    return p1[0]>0 || p2[0]>0
  end

  def winner
    p1 = find([1,2,2,1])
    p2 = find([2,1,1,2])
    if p1[0]>0 && p2[0]>0
      return DRAW
    end
    if p1[0]>0
      return P1_WIN
    end
    if p2[0]>0
      return P2_WIN
    end
    return ONGOING
  end

  # Pass in 1 if looking for OTTO, returns coordinates for first and last piece
  # Pass in 2 if looking for TOOT, returns coordinates for first and last piece
  # Pass in 3 if looking for both, returns coordinates for first and last piece for both OTTO and TOOT
  def winningMove(winner)
    a,b,c,d = find([1,2,2,1])
    e,f,g,h = find([2,1,1,2])
    if winner == 1
      if a>0
        return a,b,c,d
      end
    end
    if winner == 2
      if e>0
        return e,f,g,h
      end
    end
    if winner == 3
      if a>0&&e>0
        return a,b,c,d,e,f,g,h
      end
    end
    return -1,-1,-1,-1
  end

  def move
    for col in 0..(Game::WIDTH-1)
      if (top(col) > -1)
        @game.board[top(col)][col] = 2
      end
      if winner == 2
        return
      elsif winner == 1
        @game.board[top(col)][col] = 1
      end
    end
    begin 
      col = rand(7)
      row = top(col)
    end until row > -1
    @game.board[row][col] = 1 + rand(1);
  end

end

class C4Strategy < Strategy
  def win?
    simBoard = getSim
    p1 = find(simBoard,[1,1,1,1])
    p2 = find(simBoard,[2,2,2,2])
    return p1[0]>0 || p2[0]>0
  end

  def win(board)
    p1 = find(board,[1,1,1,1])
    p2 = find(board,[2,2,2,2])
    return p1[0]>0 || p2[0]>0
  end

  def winningMove
    simBoard = getSim
    a,b,c,d = find(simBoard,[1,1,1,1])
    if a>0
      return a,b,c,d
    else
      a,b,c,d = find(simBoard,[2,2,2,2])
      if a>0
        return a,b,c,d
      end
    end
    return -1,-1,-1,-1
  end

  def hasWin(board)
      for col in 0..(Game::WIDTH-1)
      theTop = top(board,col)
        if (top(board,col) > -1)
          board[theTop][col] = 2
          if win(board)
	    board[theTop][col] = nil
            return 2, col
          end
          board[theTop][col] = 1
          if win(board)
            board[theTop][col] = nil
            return 1, col
          end  
          board[theTop][col] = nil
	end
      end
      return 0, 0
  end

  def move
    simBoard = getSim
    if @game.difficulty >= MEDIUM
      winner, col = hasWin(simBoard)
      if winner > 0
        return col
      end
    end
    if @game.difficulty == 4
      for col in 0..(Game::WIDTH-1)
        if(top(simBoard,col) > -1)
          if(hasAdjacent(simBoard,top(simBoard,col),col,2))
            simBoard[top(simBoard.col)][col] = 2
            winner, x = hasWin(simBoard)
            simBoard[top(simBoard,col)][col] = nil
            if winner != 1 && rand(1)==1
              return col
            end
          end
        end
      end
    end
    if @game.difficulty >= 4
      for i in 1..10
        begin 
          col = rand(6)
          row = top(simBoard,col)
        end until row > -1
        simBoard[row][col] = 2;
        winner, x = hasWin(simBoard)
	simBoard[row][col] = nil;
        if winner != 1
          return col
        end
      end  
    end
    begin 
      col = rand(6)
      row = top(simBoard,col)
    end until row > -1
    return col
  end
end


